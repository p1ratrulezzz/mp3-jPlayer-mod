diff --git a/mp3j_main.php b/mp3j_main.php
index 5015d92..37535fb 100644
--- a/mp3j_main.php
+++ b/mp3j_main.php
@@ -105,6 +105,73 @@ if ( !class_exists("MP3j_Main") ) { class MP3j_Main	{
 		return $this->LibraryI;
 	}
 
+  /**
+   * Parses remote Apache index page for mp3 files
+   * @param $scheme
+   *  A protocol, like http, https (now only http)
+   * @param $folder
+   *  A url of a directory with mp3 files.
+   * @return array|bool
+   *  Returns an array of tracks and false in case of errors or if couldn't find any mp3s.
+   */
+  public function grab_remote_folder_mp3s($scheme, $folder) {
+    static $permited_exts = array(
+      'mp3' => TRUE,
+    );
+
+    // Build correct url.
+    $url = strtolower($scheme) . '://' . trim($folder, '/');
+
+    // Set fixed timeouts in order to prevent long page loadings.
+    $http_context = stream_context_create(array('http'=>
+      array(
+        'timeout' => 12, // Set 12 seconds timeout @fixme: This should go to admin settings
+      )
+    ));
+
+    // Try loading out content
+    $content = @file_get_contents($url, FALSE, $http_context); // Prevent errors. Warning might happen if timeout exceeds
+    if (!$content) {
+      return false;
+    }
+
+    $dom = new DOMDocument('1.0', 'UTF-8');
+    libxml_use_internal_errors(false);
+    $dom->loadHTML($content);
+    libxml_use_internal_errors(true);
+
+    $trs = $dom->getElementsByTagName('table')
+      ->item(0)
+      ->getElementsByTagName('tr');
+
+    $tracks = array();
+    foreach ($trs as $tr) {
+      if (($tds = $tr->getElementsByTagName('td')) && $tds->length>= 1 && ($anchors = $tds->item(1)->getElementsByTagName('a')) && $anchors->length > 0) {
+        $track_path = $anchors->item(0)->getAttribute('href');
+        if ($track_path && ($ext = pathinfo($track_path, PATHINFO_EXTENSION)) && isset($permited_exts[$ext])) {
+          $track_path = $url . '/' . $track_path;
+          $tracks[] = urldecode($track_path);
+        }
+      }
+    }
+
+    // Sort naturally.
+    if ( ($c = count($tracks)) > 0 ) {
+      natcasesort($tracks);
+      if ( $this->folder_order != "asc" ) {
+        $tracks = array_reverse($tracks, true);
+      }
+    }
+    $this->dbug['str'] .= "\nRead folder - Done, " . $c . "mp3(s) from ". urldecode($url);
+
+    // Some cleanings
+    unset($dom);
+    unset($http_context);
+    $content = null;
+
+    return !empty($tracks) ? $tracks : false;
+  }
+
 /*	Reads mp3's from a local 
 	directory, returns array of uri's */			
 	function grab_local_folder_mp3s( $folder ) {
@@ -248,10 +315,12 @@ if ( !class_exists("MP3j_Main") ) { class MP3j_Main	{
 
 /*	Adds any FEEDs into K's/V's */
 	function collect_delete_feeds( $values, $keys ){
+    $Vs = $Ks  = array(); // Let's initialize this as empty arrays in order to prevent any warning further
 		foreach ( $values as $i => $val ) {  
-			if ( preg_match( "!^FEED:(DF|ID|LIB|/.*)$!i", $val ) == 1 ) { // keep ID for backwards compat
+			if (preg_match( "!^FEED\:(HTTP\|.+|DF|ID|LIB|/.*)$!i", $val ) == 1 ) { // keep ID for backwards compat
 				$feedV = stristr( $val, ":" );
-				$feedV = str_replace( ":", "", $feedV );
+				$feedV = str_replace( ":",
+          "", $feedV );
 				$feedK = ( !empty($keys[$i]) ) ? $keys[$i] : "";
 				$fed = $this->get_feed( $feedK, $feedV ); // gets the FEED tracks
 				foreach ( $fed['Vs'] as $j => $v ) {
@@ -291,7 +360,30 @@ if ( !class_exists("MP3j_Main") ) { class MP3j_Main	{
 			if ( $feedV == "DF" ) { 
 				$feedV = $this->theSettings['mp3_dir'];
 			}
-			$tracks = $this->grab_local_folder_mp3s( $feedV ); 
+
+      // Check if we have a remote address
+      if (($ruins = explode('|', $feedV)) && strtoupper(reset($ruins)) == 'HTTP' && isset($ruins[1])) {
+        $cid = 'mp3-jplayer:' . $feedV;
+        // Provide ability to rebuild cache via $_GET parameters
+        $tracks = isset($_GET['mp3_jplayer_cache_clear']) ? FALSE : wp_cache_get($cid);
+        $tracks = $tracks ? $tracks : (object) array('expire' => strtotime('+3 hours') - time());
+        if (!isset($tracks->data)) {
+          $tracks->data = $this->grab_remote_folder_mp3s( reset($ruins), $ruins[1] ); // Use special parser
+          if (empty($tracks->data)) {
+            $tracks->data = array();
+            // Lower expiration time for empty sets just to protect from often requests.
+            $tracks->expire = strtotime('+3 minutes') - time();
+          }
+
+          wp_cache_set($cid, $tracks, '', $tracks->expire);
+        }
+
+        $tracks = $tracks->data;
+      }
+      else {
+			  $tracks = $this->grab_local_folder_mp3s( $feedV );
+      }
+
 			if ( $tracks !== true && $tracks !== false && count($tracks) > 0 ) {
 				foreach ( $tracks as $j => $x ) {
 					$Vs[] = $x;
